this is a good example of a sql updater for my supabase db.  Rigorous.   **MUST BE AWARE : The INSERT ... ON CONFLICT DO UPDATE pattern for the production table to ensure that data sticks.
-- Ensure update_log table exists
CREATE TABLE IF NOT EXISTS public.update_log (
    log_id SERIAL PRIMARY KEY,
    company_id INTEGER,
    table_name TEXT,
    update_time TIMESTAMP WITH TIME ZONE,
    update_description TEXT
);

-- Begin transaction
BEGIN;

-- Lock rows to prevent concurrent updates
SELECT * FROM public.companies WHERE company_id = 277 FOR UPDATE;
SELECT * FROM public.financials WHERE company_id = 277 FOR UPDATE;
SELECT * FROM public.production WHERE company_id = 277 FOR UPDATE;
SELECT * FROM public.mineral_estimates WHERE company_id = 277 FOR UPDATE;
SELECT * FROM public.valuation_metrics WHERE company_id = 277 FOR UPDATE;

-- Log pre-update state for companies
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
SELECT 
    277,
    'companies',
    NOW(),
    'Pre-update state: company_name = ' || COALESCE(company_name::TEXT, 'NULL') || ', status = ' || COALESCE(status::TEXT, 'NULL')
FROM public.companies
WHERE company_id = 277;

-- Update companies
UPDATE public.companies
SET
    tsx_code = 'MUX.TO',
    company_name = 'McEwen Mining Inc.',
    status = 'producer',
    description = 'Gold and silver producer with operations in Nevada (Gold Bar), Ontario (Fox Complex), and Argentina (San José, 49% owned), plus a 46.4% stake in McEwen Copper (Los Azules).',
    headquarters = 'Toronto, Canada',
    minerals_of_interest = 'gold, silver, copper',
    percent_gold = 80,
    percent_silver = 15,
    last_updated = NOW()
WHERE company_id = 277;

-- Log companies update
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
VALUES (277, 'companies', NOW(), 'Updated company details, description, and mineral percentages');

-- Log pre-update state for financials
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
SELECT 
    277,
    'financials',
    NOW(),
    'Pre-update state: market_cap_value = ' || COALESCE(market_cap_value::TEXT, 'NULL') || ', enterprise_value_value = ' || COALESCE(enterprise_value_value::TEXT, 'NULL')
FROM public.financials
WHERE company_id = 277;

-- Update financials
UPDATE public.financials
SET
    market_cap_value = 595605000, -- CAD
    market_cap_currency = 'CAD',
    enterprise_value_value = 663920000, -- CAD
    enterprise_value_currency = 'CAD',
    revenue_value = 168945000, -- USD
    ebitda = 34800000, -- USD (Q1 annualized)
    net_income_value = -15600000, -- USD (Q1 annualized)
    cash_value = 68500000, -- USD
    cash_currency = 'USD',
    cash_date = '2025-03-31',
    debt_value = 130000000, -- USD
    debt_currency = 'USD',
    liabilities = 130000000, -- USD
    liabilities_currency = 'USD',
    price_to_sales = 2.42,
    price_to_book = 0.89,
    enterprise_to_revenue = 2.84,
    enterprise_to_ebitda = ROUND(488180000 / 34800000, 2), -- ~14.03
    free_cash_flow = -29466000, -- USD
    gross_profit = 40400000, -- USD (Q1 annualized)
    operating_income = NULL,
    operating_expense = 128545000, -- USD (estimated)
    cost_of_revenue = 0, -- USD
    forward_pe = 9.18,
    shares_outstanding = 53270000,
    data_source = 'GlobeNewswire, Yahoo Finance',
    last_updated = NOW()
WHERE company_id = 277;

-- Log financials update
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
VALUES (277, 'financials', NOW(), 'Updated market cap, EV, revenue, EBITDA, net income, cash, debt, liabilities, and financial ratios with Q1 2025 data');

-- Log pre-update state for production
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
SELECT 
    277,
    'production',
    NOW(),
    'Pre-update state: current_production_total_aueq_koz = ' || COALESCE(current_production_total_aueq_koz::TEXT, 'NULL')
FROM public.production
WHERE company_id = 277;

-- Update production
UPDATE public.production
SET
    current_production_total_aueq_koz = 130, -- Guidance midpoint
    current_production_precious_aueq_koz = 130,
    current_production_non_precious_aueq_koz = 0,
    future_production_total_aueq_koz = 240, -- 2030 target midpoint
    reserve_life_years = ROUND((0.50 * 1000) / 130, 2), -- ~3.85 years
    protected = FALSE,
    last_updated = NOW()
WHERE company_id = 277;

-- Log production update
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
VALUES (277, 'production', NOW(), 'Updated current production to 130,000 oz (guidance midpoint), future to 240,000 oz, and reserve life to 3.85 years');

-- Log pre-update state for mineral estimates
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
SELECT 
    277,
    'mineral_estimates',
    NOW(),
    'Pre-update state: reserves_total_aueq_moz = ' || COALESCE(reserves_total_aueq_moz::TEXT, 'NULL')
FROM public.mineral_estimates
WHERE company_id = 277;

-- Update mineral estimates
UPDATE public.mineral_estimates
SET
    reserves_total_aueq_moz = 0.50, -- Proven & Probable
    reserves_precious_aueq_moz = 0.50,
    reserves_non_precious_aueq_moz = 0,
    resources_total_aueq_moz = 3.00, -- Total
    resources_precious_aueq_moz = 3.00,
    resources_non_precious_aueq_moz = 0,
    measured_indicated_total_aueq_moz = 2.00,
    measured_indicated_precious_aueq_moz = 2.00,
    measured_indicated_non_precious_aueq_moz = 0,
    last_updated = NOW()
WHERE company_id = 277;

-- Log mineral estimates update
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
VALUES (277, 'mineral_estimates', NOW(), 'Updated reserves to 0.50M oz, resources to 3.00M oz, M&I to 2.00M oz (all precious)');

-- Log pre-update state for valuation metrics
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
SELECT 
    277,
    'valuation_metrics',
    NOW(),
    'Pre-update state: ev_per_production_oz = ' || COALESCE(ev_per_production_oz::TEXT, 'NULL') || ', mkt_cap_per_production_oz = ' || COALESCE(mkt_cap_per_production_oz::TEXT, 'NULL')
FROM public.valuation_metrics
WHERE company_id = 277;

-- Update valuation metrics
UPDATE public.valuation_metrics
SET
    ev_per_production_oz = ROUND((663920000 / 1.36) / (130 * 1000), 2), -- ~$3755.23/oz USD
    mkt_cap_per_production_oz = ROUND((595605000 / 1.36) / (130 * 1000), 2), -- ~$3369.92/oz USD
    ev_per_reserve_oz_all = ROUND((663920000 / 1.36) / (0.50 * 1000000), 2), -- ~$976.36/oz USD
    ev_per_resource_oz_all = ROUND((663920000 / 1.36) / (3.00 * 1000000), 2), -- ~$162.73/oz USD
    ev_per_mi_oz_all = ROUND((663920000 / 1.36) / (2.00 * 1000000), 2), -- ~$244.09/oz USD
    mkt_cap_per_reserve_oz_all = ROUND((595605000 / 1.36) / (0.50 * 1000000), 2), -- ~$875.80/oz USD
    mkt_cap_per_resource_oz_all = ROUND((595605000 / 1.36) / (3.00 * 1000000), 2), -- ~$145.97/oz USD
    mkt_cap_per_mi_oz_all = ROUND((595605000 / 1.36) / (2.00 * 1000000), 2), -- ~$218.95/oz USD
    ev_per_reserve_oz_precious = ROUND((663920000 / 1.36) / (0.50 * 1000000), 2), -- ~$976.36/oz USD
    ev_per_resource_oz_precious = ROUND((663920000 / 1.36) / (3.00 * 1000000), 2), -- ~$162.73/oz USD
    ev_per_mi_oz_precious = ROUND((663920000 / 1.36) / (2.00 * 1000000), 2), -- ~$244.09/oz USD
    mkt_cap_per_reserve_oz_precious = ROUND((595605000 / 1.36) / (0.50 * 1000000), 2), -- ~$875.80/oz USD
    mkt_cap_per_resource_oz_precious = ROUND((595605000 / 1.36) / (3.00 * 1000000), 2), -- ~$145.97/oz USD
    mkt_cap_per_mi_oz_precious = ROUND((595605000 / 1.36) / (2.00 * 1000000), 2), -- ~$218.95/oz USD
    last_updated = NOW()
WHERE company_id = 277;

-- Log valuation metrics update
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
VALUES (277, 'valuation_metrics', NOW(), 'Updated EV and market cap metrics for production (guidance midpoint), reserves, resources, and M&I');

-- Verify updates
SELECT
    c.company_id,
    c.tsx_code,
    c.company_name,
    c.status,
    f.market_cap_value,
    f.market_cap_currency,
    f.enterprise_value_value,
    f.enterprise_value_currency,
    f.revenue_value,
    f.ebitda,
    f.net_income_value,
    f.cash_value,
    f.debt_value,
    f.liabilities,
    p.current_production_total_aueq_koz,
    p.current_production_precious_aueq_koz,
    me.reserves_total_aueq_moz,
    me.resources_total_aueq_moz,
    me.measured_indicated_total_aueq_moz,
    vm.ev_per_production_oz,
    vm.mkt_cap_per_production_oz,
    vm.ev_per_reserve_oz_all,
    vm.ev_per_resource_oz_all,
    vm.ev_per_mi_oz_all,
    vm.last_updated
FROM public.companies c
LEFT JOIN public.financials f ON c.company_id = f.company_id
LEFT JOIN public.production p ON c.company_id = p.company_id
LEFT JOIN public.mineral_estimates me ON c.company_id = me.company_id
LEFT JOIN public.valuation_metrics vm ON c.company_id = vm.company_id
WHERE c.company_id = 277;

-- Commit transaction
COMMIT;

-- Run data quality query for McEwen, Galiano, Mineros, Amaroq
WITH data_quality_metrics AS (
    SELECT DISTINCT ON (c.company_id)
        c.company_id,
        c.tsx_code,
        c.company_name,
        c.status,
        p.current_production_total_aueq_koz,
        p.protected AS production_protected,
        p.last_updated AS production_last_updated,
        f.market_cap_value,
        me.reserves_total_aueq_moz,
        me.measured_indicated_total_aueq_moz,
        vm.ev_per_production_oz,
        vm.ev_per_reserve_oz_all,
        f.data_source,
        CASE 
            WHEN c.status = 'producer' AND (p.current_production_total_aueq_koz IS NULL OR p.current_production_total_aueq_koz <= 0) THEN 'MISSING: Production for Producer'
            WHEN c.status = 'developer' AND (me.reserves_total_aueq_moz IS NULL OR (me.reserves_total_aueq_moz <= 0 AND me.measured_indicated_total_aueq_moz <= 0)) THEN 'MISSING: Reserves for Developer'
            WHEN p.current_production_total_aueq_koz IS NULL THEN 'ERROR: No Production Record'
            ELSE 'OK'
        END AS production_issue,
        CASE 
            WHEN vm.ev_per_production_oz > 100000 AND p.current_production_total_aueq_koz > 0 THEN 'ANOMALY: EV/Production > $100,000/oz'
            WHEN vm.ev_per_reserve_oz_all > 5000 AND me.reserves_total_aueq_moz > 0 THEN 'ANOMALY: EV/Reserves > $5,000/oz'
            ELSE 'OK'
        END AS valuation_anomaly,
        COALESCE(EXTRACT(EPOCH FROM (NOW() - p.last_updated))/86400, 9999)::INTEGER AS days_since_production_update,
        (
            CASE WHEN f.market_cap_value IS NOT NULL THEN 25 ELSE 0 END +
            CASE WHEN p.current_production_total_aueq_koz IS NOT NULL THEN 25 ELSE 0 END +
            CASE WHEN me.reserves_total_aueq_moz IS NOT NULL THEN 25 ELSE 0 END
        ) AS completeness_score
    FROM public.companies c
    LEFT JOIN public.production p ON c.company_id = p.company_id
    LEFT JOIN public.financials f ON c.company_id = f.company_id
    LEFT JOIN public.mineral_estimates me ON c.company_id = me.company_id
    LEFT JOIN public.valuation_metrics vm ON c.company_id = vm.company_id
    WHERE c.company_id IN (27, 160, 272, 277)
    ORDER BY c.company_id, p.last_updated DESC NULLS LAST
)
SELECT 
    company_id,
    tsx_code,
    company_name,
    status,
    completeness_score || '%' AS completeness,
    CASE 
        WHEN production_issue != 'OK' THEN production_issue
        WHEN valuation_anomaly != 'OK' THEN valuation_anomaly
        ELSE 'OK'
    END AS priority_reason,
    ARRAY[production_issue, valuation_anomaly] AS issues,
    ROUND(CASE 
        WHEN production_issue LIKE 'MISSING%' THEN 90 * (CASE WHEN status = 'producer' THEN 1.3 ELSE 1.2 END)
        WHEN valuation_anomaly LIKE 'ANOMALY%' THEN 20
        ELSE 0 
    END, 2) AS severity_score,
    CASE 
        WHEN market_cap_value >= 1000000000 THEN '$' || (market_cap_value/1000000000)::numeric(10,2)::text || 'B'
        WHEN market_cap_value >= 1000000 THEN '$' || (market_cap_value/1000000)::numeric(10,0)::text || 'M'
        ELSE 'N/A'
    END AS market_cap,
    COALESCE(reserves_total_aueq_moz, 0)::numeric(10,2) AS reserves_moz,
    COALESCE(current_production_total_aueq_koz, 0)::numeric(10,0) AS production_koz_pa,
    CASE 
        WHEN ev_per_production_oz IS NOT NULL THEN '$' || ev_per_production_oz::numeric(10,0)::text || '/oz'
        ELSE 'N/A'
    END AS ev_per_prod_oz,
    CASE 
        WHEN ev_per_reserve_oz_all IS NOT NULL THEN '$' || ev_per_reserve_oz_all::numeric(10,0)::text || '/oz'
        ELSE 'N/A'
    END AS ev_per_reserve_oz
FROM data_quality_metrics
ORDER BY severity_score DESC, company_id;

-- Check for non-system triggers
SELECT 
    tgname AS trigger_name,
    tgtype AS trigger_type,
    tgfoid::regproc AS trigger_function,
    CASE 
        WHEN (tgtype & (1 << 1))::boolean THEN 'BEFORE'
        ELSE 'AFTER'
    END AS trigger_timing,
    CASE 
        WHEN (tgtype & (1 << 2))::boolean THEN 'INSERT'
        WHEN (tgtype & (1 << 4))::boolean THEN 'UPDATE'
        WHEN (tgtype & (1 << 5))::boolean THEN 'TRUNCATE'
        ELSE 'MULTIPLE'
    END AS trigger_event
FROM pg_trigger
WHERE tgrelid = 'public.valuation_metrics'::regclass
  AND NOT tgname LIKE 'RI_ConstraintTrigger%';

-- Check for Supabase functions (potential overwrites)
SELECT 
    proname AS function_name,
    prosrc AS function_source,
    prokind AS function_kind
FROM pg_proc
WHERE pronamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public')
  AND prosrc ILIKE '%valuation_metrics%';


ESPECIALLY DONT GET STUCK LIKE WE DID HERE:
"The outputs confirm that current_production_total_aueq_koz is now correctly set for Galiano Gold (company_id 160: 95 koz), Orezone Gold (company_id 314: 100 koz), and McEwen Mining (company_id 277: 130 koz), with McEwen’s aisc_last_quarter updated to 1500. The loop output for Galiano and the successful updates for Orezone and McEwen indicate that the missing production rows were the primary issue, resolved by the INSERT and direct updates via service_role.
The protected column is false for Orezone, and production_audit logged Galiano’s update, showing database integrity. 
However, prior update_log entries (e.g., log_id 364) didn’t persist due to missing rows, and a data quality process flagging “MISSING: Production for Producer” suggests a potential reset risk."



4. Rules, Learnings, and Templates for Future Updates
Based on our conversation history and the data provided, here are the rules, learnings, and templates to guide future updates to your Supabase database. These are tailored to handle data dumps from sources like Yahoo Finance and GoldStockData, ensuring robust, consistent updates.
Learnings from Conversation History
Database Structure Insights:
Your database is centered around mining companies with tables: companies, financials, capital_structure, mineral_estimates, production, costs, stock_prices, and valuation_metrics.

Key fields like market_cap_value, shares_outstanding, current_production_total_aueq_koz, and reserves_total_aueq_moz are critical for analysis but often missing or inconsistent.

Currency handling is crucial (CAD for market data, USD for financials/costs).

Royalty/streaming companies (e.g., Franco-Nevada, Wheaton) require special handling due to no direct reserves.

Production data for producers and developers is vital but prone to not saving correctly.

Common Issues:
Production Data Loss: Production values (e.g., i-80 Gold’s 20 koz) sometimes fail to persist, leading to zero or NULL in reports.

Valuation Errors: Extreme ev_per_production_oz values (e.g., millions/oz) often result from low production or calculation errors.

Share Count Mismatches: Discrepancies between financials.shares_outstanding and capital_structure.existing_shares.

Currency Inconsistencies: Mixing CAD (market data) and USD (financials) requires careful conversion (e.g., using 1.36 CAD/USD).

Stale Data: Data older than 90 days is common, especially for smaller companies.

Royalty Misclassification: Companies like Franco-Nevada are flagged as producers when they should be royalty.

AND ANOTHER GREAT UPDATER :
-- Kuya Silver Corporation (KUYA.CN, company_id = 224) Rigorous Cautious Updater
-- CRITICAL FIX for production data persistence using INSERT ... ON CONFLICT.
-- Addresses "Missing Production" and re-confirms other data based on News, GSD, YF, and current DB state.

BEGIN;

-- Lock rows for Company ID 224 (locking tables involved in the transaction)
SELECT * FROM public.companies WHERE company_id = 224 FOR UPDATE;
SELECT * FROM public.financials WHERE company_id = 224 FOR UPDATE;
SELECT * FROM public.capital_structure WHERE company_id = 224 FOR UPDATE;
SELECT * FROM public.mineral_estimates WHERE company_id = 224 FOR UPDATE;
-- Attempt to lock production row if it exists, won't fail if it doesn't for the UPSERT logic.
SELECT * FROM public.production WHERE company_id = 224 FOR UPDATE NOWAIT; -- NOWAIT can be useful
SELECT * FROM public.costs WHERE company_id = 224 FOR UPDATE;
SELECT * FROM public.valuation_metrics WHERE company_id = 224 FOR UPDATE;

-- Log pre-update state for companies
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
SELECT
    224,
    'companies',
    NOW(),
    'Pre-update state: company_name = ' || COALESCE(c.company_name::TEXT, 'NULL') ||
    ', status = ' || COALESCE(c.status::TEXT, 'NULL') ||
    ', minerals_of_interest = ' || COALESCE(c.minerals_of_interest::TEXT, 'NULL') ||
    ', percent_silver = ' || COALESCE(c.percent_silver::TEXT, 'NULL') ||
    ', percent_gold = ' || COALESCE(c.percent_gold::TEXT, 'NULL')
FROM public.companies c
WHERE c.company_id = 224;

-- Update company information for Kuya Silver Corporation
UPDATE public.companies
SET
    company_name = 'Kuya Silver Corporation',
    tsx_code = 'KUYA.CN', -- CSE listing
    status = 'producer', -- Ramping up
    headquarters = 'Toronto, Canada',
    description = 'Kuya Silver Corporation is an emerging silver producer, ramping up operations at its Bethania mine in Peru (re-started May 2024). Also holds exploration assets in Canada. Sold 8,888 AgEq oz in Q1 2025. Targeting 100 tpd by Q3 2025. [Data Source: YF, GSD, Company News, DB Snapshot Review, Updated: ' || CURRENT_DATE::text || ']',
    minerals_of_interest = 'silver, lead, zinc, gold',
    percent_silver = 76, -- Based on Q1 2025 news, proportion of AgEq from Ag metal
    percent_gold = 1,
    last_updated = NOW()
WHERE company_id = 224;

-- Log companies update
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
VALUES (224, 'companies', NOW(), 'Updated company details: status confirmed producer (ramping up), description updated, minerals & percentages aligned with DB/News.');

-- Log pre-update state for financials
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
SELECT
    224,
    'financials',
    NOW(),
    'Pre-update state: MCap = ' || COALESCE(f.market_cap_value::TEXT, 'NULL') || ' ' || COALESCE(f.market_cap_currency,'') ||
    ', Revenue = ' || COALESCE(f.revenue_value::TEXT, 'NULL') || ' ' || COALESCE(f.revenue_currency,'') ||
    ', NI = ' || COALESCE(f.net_income_value::TEXT, 'NULL') || ' ' || COALESCE(f.net_income_currency,'') ||
    ', Shares = ' || COALESCE(f.shares_outstanding::TEXT, 'NULL')
FROM public.financials f
WHERE f.company_id = 224;

-- Update financial data for Kuya Silver Corporation
UPDATE public.financials
SET
    cash_value = 765570,
    cash_currency = 'CAD',
    cash_date = '2025-03-31',
    debt_value = 0,
    debt_currency = 'CAD',
    market_cap_value = 30391000,
    market_cap_currency = 'CAD',
    enterprise_value_value = (30391000 - 765570),
    enterprise_value_currency = 'CAD',
    revenue_value = ROUND(228630 * 4), -- USD (Annualized Q1 2025 revenue from Company News - $228.63k * 4)
    revenue_currency = 'USD',
    net_income_value = COALESCE(net_income_value, -6050000),
    net_income_currency = COALESCE(net_income_currency, 'CAD'),
    shares_outstanding = 106635087,
    price_to_sales = ROUND((30391000 / 1.36) / NULLIF(228630 * 4,0), 2),
    ebitda = COALESCE(ebitda, -6222985),
    investments_json = jsonb_build_object(
        'UpdateContext', 'Addressing production data persistence. Using annualized Q1 2025 AgEq sales for current production. Revenue set to USD from Q1 News.',
        'ProductionNote', 'Current prod 0.444 AuEq koz from annualized Q1 2025 AgEq sales (8,888 AgEq oz * 4 / 80 ratio). Ramping up.',
        'RevenueSource', 'Q1 2025 Company News (annualized USD $914,520).',
        'DataSourceUsed', 'Yahoo Finance (May25) + GoldStockData (Oct24) + Company News (Q1 2025 Ops Report May25) + DB Snapshot Review'
    ),
    data_source = 'Yahoo Finance + GoldStockData + Company News + DB Snapshot Review',
    last_updated = NOW()
WHERE company_id = 224;

-- Log financials update
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
VALUES (224, 'financials', NOW(), 'Updated financials: Revenue set to annualized Q1_25 USD. Other fields aligned with DB/latest YF. JSON notes updated.');

-- Log pre-update state for capital_structure
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
SELECT 224, 'capital_structure', NOW(), 'Pre-update state: existing_shares = ' || COALESCE(cs.existing_shares::TEXT, 'NULL') || ', fully_diluted_shares = ' || COALESCE(cs.fully_diluted_shares::TEXT, 'NULL') FROM public.capital_structure cs WHERE cs.company_id = 224;
UPDATE public.capital_structure
SET
    existing_shares = 106635087,
    fully_diluted_shares = COALESCE(fully_diluted_shares, 152427266),
    in_the_money_options = COALESCE(in_the_money_options, (152427266 - 106635087)),
    last_updated = NOW()
WHERE company_id = 224;
INSERT INTO public.update_log (company_id, table_name, update_time, update_description) VALUES (224, 'capital_structure', NOW(), 'Confirmed/updated share counts based on YF derived and GSD.');

-- Log pre-update state for mineral_estimates
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
SELECT 224, 'mineral_estimates', NOW(), 'Pre-update state: resources_total_aueq_moz = ' || COALESCE(me.resources_total_aueq_moz::TEXT, 'NULL') || ', measured_indicated_total_aueq_moz = ' || COALESCE(me.measured_indicated_total_aueq_moz::TEXT, 'NULL') FROM public.mineral_estimates me WHERE me.company_id = 224;
UPDATE public.mineral_estimates
SET
    reserves_precious_aueq_moz = 0,
    measured_indicated_precious_aueq_moz = 0,
    resources_precious_aueq_moz = 0,
    potential_precious_aueq_moz = 0,
    reserves_non_precious_aueq_moz = 0,
    measured_indicated_non_precious_aueq_moz = 0.075,
    resources_non_precious_aueq_moz = 0.200,
    potential_non_precious_aueq_moz = 0.125,
    reserves_total_aueq_moz = 0,
    measured_indicated_total_aueq_moz = 0.075,
    resources_total_aueq_moz = 0.200,
    potential_total_aueq_moz = 0.125,
    last_updated = NOW()
WHERE company_id = 224;
INSERT INTO public.update_log (company_id, table_name, update_time, update_description) VALUES (224, 'mineral_estimates', NOW(), 'Confirmed mineral estimates (AuEq from GSD Ag resources) align with current DB.');

-- Log pre-update state for production (if row exists)
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
SELECT 224, 'production', NOW(), 'Pre-UPSERT state: current_production_total_aueq_koz = ' || COALESCE(p.current_production_total_aueq_koz::TEXT, 'NULL') FROM public.production p WHERE p.company_id = 224;

-- Upsert production data for Kuya Silver (CRITICAL FIX)
INSERT INTO public.production (
    company_id,
    current_production_total_aueq_koz,
    current_production_precious_aueq_koz,
    current_production_non_precious_aueq_koz,
    future_production_total_aueq_koz,
    reserve_life_years,
    protected,
    last_updated
) VALUES (
    224, -- company_id
    ROUND((8887.57 * 4)::numeric / 80 / 1000, 3), -- current_production_total_aueq_koz (0.444 AuEq koz)
    ROUND((2.28 * 4)::numeric / 1000, 3),        -- current_production_precious_aueq_koz (0.009 Au koz from Q1 Au sold)
    ROUND(((8887.57 * 4) - (2.28 * 4 * 80))::numeric / 80 / 1000, 3), -- current_production_non_precious_aueq_koz (0.435 AuEq koz from remaining AgEq)
    ROUND(2000000::numeric / 80 / 1000, 3),      -- future_production_total_aueq_koz (GSD Future Ag Prod 2M oz -> 25 AuEq Koz)
    0,                                           -- reserve_life_years (No reserves)
    FALSE,                                       -- protected
    NOW()                                        -- last_updated
)
ON CONFLICT (company_id) DO UPDATE SET
    current_production_total_aueq_koz = EXCLUDED.current_production_total_aueq_koz,
    current_production_precious_aueq_koz = EXCLUDED.current_production_precious_aueq_koz,
    current_production_non_precious_aueq_koz = EXCLUDED.current_production_non_precious_aueq_koz,
    future_production_total_aueq_koz = COALESCE(public.production.future_production_total_aueq_koz, EXCLUDED.future_production_total_aueq_koz), -- Keep existing DB future prod if not null
    reserve_life_years = EXCLUDED.reserve_life_years,
    protected = EXCLUDED.protected,
    last_updated = EXCLUDED.last_updated;

INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
VALUES (224, 'production', NOW(), 'CRITICAL FIX: UPSERTED production data. Current production set to 0.444 koz AuEq (Annualized Q1 2025 AgEq from Company News).');

-- Log pre-update state for costs
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
SELECT 224, 'costs', NOW(), 'Pre-update state: aisc_last_year = ' || COALESCE(c.aisc_last_year::TEXT, 'NULL') || ', tco_current = ' || COALESCE(c.tco_current::TEXT, 'NULL') FROM public.costs c WHERE c.company_id = 224;
UPDATE public.costs
SET
    tco_current = COALESCE(tco_current, (12 * 80)),
    tco_current_currency = COALESCE(tco_current_currency, 'USD'),
    aisc_last_year = COALESCE(aisc_last_year, (22 * 80)),
    aisc_last_year_currency = COALESCE(aisc_last_year_currency, 'USD'),
    tco_future = COALESCE(tco_future, (15*80)),
    tco_future_currency = COALESCE(tco_future_currency, 'USD'),
    aisc_future = COALESCE(aisc_future, ((15+10)*80)),
    aisc_future_currency = COALESCE(aisc_future_currency, 'USD'),
    last_updated = NOW()
WHERE company_id = 224;
INSERT INTO public.update_log (company_id, table_name, update_time, update_description) VALUES (224, 'costs', NOW(), 'Confirmed/updated cost data (AuEq from GSD Ag costs), preserving existing if present.');

-- Update stock price
INSERT INTO public.stock_prices (company_id, price_value, price_currency, price_date, data_source)
VALUES (224, 0.2850, 'CAD', '2025-05-23', 'Yahoo Finance')
ON CONFLICT (company_id, price_date, data_source)
DO UPDATE SET price_value = EXCLUDED.price_value, price_currency = EXCLUDED.price_currency, last_updated = NOW();
INSERT INTO public.update_log (company_id, table_name, update_time, update_description) VALUES (224, 'stock_prices', NOW(), 'Upserted stock price from Yahoo Finance (May 23, 2025).');

-- Log pre-update state for valuation_metrics
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
SELECT 224, 'valuation_metrics', NOW(), 'Pre-update state: ev_per_production_oz = ' || COALESCE(vm.ev_per_production_oz::TEXT, 'NULL') || ', mkt_cap_per_production_oz = ' || COALESCE(vm.mkt_cap_per_production_oz::TEXT, 'NULL') FROM public.valuation_metrics vm WHERE vm.company_id = 224;
-- Recalculate valuation metrics
UPDATE public.valuation_metrics
SET
    ev_per_production_oz = ROUND( (29625430 / 1.36)::numeric / NULLIF( ((8887.57 * 4) / 80 / 1000) , 0), 2), -- EV_USD / Prod_AuEq_koz
    mkt_cap_per_production_oz = ROUND( (30391000 / 1.36)::numeric / NULLIF( ((8887.57 * 4) / 80 / 1000) , 0), 2), -- MCap_USD / Prod_AuEq_koz
    ev_per_reserve_oz_all = NULL,
    mkt_cap_per_reserve_oz_all = NULL,
    ev_per_mi_oz_all = ROUND( (29625430 / 1.36)::numeric / NULLIF( (6000000 / 80) , 0), 2), -- EV_USD / M&I_AuEq_oz (M&I is 0.075 Moz = 75000 oz)
    mkt_cap_per_mi_oz_all = ROUND( (30391000 / 1.36)::numeric / NULLIF( (6000000 / 80) , 0), 2),
    ev_per_resource_oz_all = ROUND( (29625430 / 1.36)::numeric / NULLIF( (16000000 / 80) , 0), 2), -- EV_USD / Resources_AuEq_oz (Res is 0.2 Moz = 200000 oz)
    mkt_cap_per_resource_oz_all = ROUND( (30391000 / 1.36)::numeric / NULLIF( (16000000 / 80) , 0), 2),
    last_updated = NOW()
WHERE company_id = 224;
INSERT INTO public.update_log (company_id, table_name, update_time, update_description) VALUES (224, 'valuation_metrics', NOW(), 'Recalculated valuation metrics based on updated production and financials.');

-- Verify updates for KUYA.CN
SELECT
    c.company_id, c.tsx_code, c.status,
    p.current_production_total_aueq_koz AS actual_prod_koz,
    f.revenue_value AS f_rev_usd, f.revenue_currency AS f_rev_curr,
    vm.ev_per_production_oz
FROM public.companies c
LEFT JOIN public.financials f ON c.company_id = f.company_id
LEFT JOIN public.production p ON c.company_id = p.company_id
LEFT JOIN public.valuation_metrics vm ON c.company_id = vm.company_id
WHERE c.company_id = 224;

COMMIT;

---

I also think like this is a super robust way to do things :
-- #############################################################################
-- # Rigorous SQL Updater Template for a Single Company (Excludes stock_prices Update)
-- # Version: 2.1
-- #
-- # Instructions:
-- # 1. Replace ALL [PLACEHOLDER_VALUES] with actual data for the company.
-- # 2. If new data for a specific field is NOT available, OMIT that line
-- #    from the SET clause in the relevant UPDATE statement to avoid
-- #    overwriting existing data with NULL.
-- # 3. Ensure company_id exists in dependent tables if only performing UPDATE.
-- #    UPSERT (INSERT ... ON CONFLICT) is used for tables where rows might be missing.
-- # 4. Verify currency consistency for financial calculations.
-- #############################################################################

-- Provide the Company ID and Key Identifiers for this update run
-- Example: WITH company_vars AS (SELECT 174 AS id, 'GOLD.TO' AS ticker)
WITH company_vars AS (
    SELECT [COMPANY_ID_NUMERIC] AS id, '[TICKER_TEXT]' AS ticker
)

BEGIN;

-- Lock rows for the company across all relevant tables (excluding stock_prices for write)
SELECT * FROM public.companies WHERE company_id = (SELECT id FROM company_vars) FOR UPDATE;
SELECT * FROM public.financials WHERE company_id = (SELECT id FROM company_vars) FOR UPDATE;
SELECT * FROM public.capital_structure WHERE company_id = (SELECT id FROM company_vars) FOR UPDATE;
SELECT * FROM public.mineral_estimates WHERE company_id = (SELECT id FROM company_vars) FOR UPDATE NOWAIT;
SELECT * FROM public.production WHERE company_id = (SELECT id FROM company_vars) FOR UPDATE NOWAIT;
SELECT * FROM public.costs WHERE company_id = (SELECT id FROM company_vars) FOR UPDATE NOWAIT;
SELECT * FROM public.valuation_metrics WHERE company_id = (SELECT id FROM company_vars) FOR UPDATE;
SELECT * FROM public.company_urls WHERE company_id = (SELECT id FROM company_vars) FOR UPDATE NOWAIT;
-- public.stock_prices table is read for MCap calculation but not locked for write here.

--------------------------------------------------------------------------
-- Update public.companies
--------------------------------------------------------------------------
-- Log pre-update state
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
SELECT
    (SELECT id FROM company_vars),
    'companies',
    NOW(),
    'Pre-update state: name=' || COALESCE(c.company_name::TEXT, 'NULL') ||
    ', status=' || COALESCE(c.status::TEXT, 'NULL') ||
    ', ticker=' || COALESCE(c.tsx_code::TEXT, 'NULL') ||
    ', minerals=' || COALESCE(c.minerals_of_interest::TEXT, 'NULL') ||
    ', desc_len=' || COALESCE(LENGTH(c.description)::TEXT, 'NULL')
FROM public.companies c
WHERE c.company_id = (SELECT id FROM company_vars);

UPDATE public.companies
SET
    company_name = '[NEW_COMPANY_NAME_TEXT]',
    tsx_code = '[NEW_TSX_CODE_TEXT]',
    status = '[NEW_STATUS_TEXT]', -- e.g., 'developer', 'producer'
    headquarters = '[NEW_HEADQUARTERS_TEXT]',
    description = '[NEW_DESCRIPTION_TEXT]',
    minerals_of_interest = '[NEW_MINERALS_TEXT]',
    percent_gold = [NEW_PERCENT_GOLD_NUMERIC],
    percent_silver = [NEW_PERCENT_SILVER_NUMERIC],
    last_updated = NOW()
WHERE company_id = (SELECT id FROM company_vars);

-- Log post-update
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
VALUES ((SELECT id FROM company_vars), 'companies', NOW(), 'Updated company profile information.');

--------------------------------------------------------------------------
-- Update public.financials
--------------------------------------------------------------------------
-- Log pre-update state
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
SELECT
    (SELECT id FROM company_vars),
    'financials',
    NOW(),
    'Pre-update state: MCap=' || COALESCE(f.market_cap_value::TEXT, 'NULL') || ' ' || COALESCE(f.market_cap_currency,'') ||
    ', Revenue=' || COALESCE(f.revenue_value::TEXT, 'NULL') || ' ' || COALESCE(f.revenue_currency,'') ||
    ', Cash=' || COALESCE(f.cash_value::TEXT, 'NULL') || ' ' || COALESCE(f.cash_currency,'') ||
    ', Debt=' || COALESCE(f.debt_value::TEXT, 'NULL') || ' ' || COALESCE(f.debt_currency,'') ||
    ', Shares=' || COALESCE(f.shares_outstanding::TEXT, 'NULL')
FROM public.financials f
WHERE f.company_id = (SELECT id FROM company_vars);

-- Derive Market Cap if NULL using latest stock price (read-only from stock_prices)
WITH latest_price AS (
    SELECT
        sp.price_value,
        sp.price_currency
    FROM public.stock_prices sp
    WHERE sp.company_id = (SELECT id FROM company_vars)
    ORDER BY sp.price_date DESC, sp.last_updated DESC
    LIMIT 1
)
UPDATE public.financials f
SET
    market_cap_value = COALESCE(f.market_cap_value, lp.price_value * f.shares_outstanding),
    market_cap_currency = COALESCE(f.market_cap_currency, lp.price_currency)
FROM latest_price lp
WHERE f.company_id = (SELECT id FROM company_vars)
  AND f.market_cap_value IS NULL        -- Only if MCap is NULL
  AND f.shares_outstanding IS NOT NULL
  AND lp.price_value IS NOT NULL;

-- Log MCap derivation attempt
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
VALUES ((SELECT id FROM company_vars), 'financials', NOW(), 'Attempted to derive market_cap_value if NULL (Price*Shares).');

-- Main Financials Update
UPDATE public.financials
SET
    -- market_cap_value: Updated above if was NULL, or set directly if new MCap data available
    -- market_cap_currency: Updated above if MCap was derived, or set directly
    cash_value = [NEW_CASH_VALUE_NUMERIC],
    cash_currency = '[NEW_CASH_CURRENCY_TEXT]',
    cash_date = '[NEW_CASH_DATE_YYYY-MM-DD]',
    debt_value = [NEW_DEBT_VALUE_NUMERIC],
    debt_currency = '[NEW_DEBT_CURRENCY_TEXT]',
    shares_outstanding = [NEW_SHARES_OUTSTANDING_NUMERIC],
    enterprise_value_value = ROUND( (COALESCE(market_cap_value, 0) / COALESCE([FX_RATE_CAD_PER_USD_NUMERIC_FOR_MCAP_IF_NEEDED], 1.0)) + COALESCE([NEW_DEBT_VALUE_NUMERIC_IN_EV_CURRENCY], COALESCE(debt_value,0)) - COALESCE([NEW_CASH_VALUE_NUMERIC_IN_EV_CURRENCY], COALESCE(cash_value,0)) )::numeric, -- Ensure all in EV_CURRENCY
    enterprise_value_currency = '[TARGET_EV_CURRENCY_TEXT]', -- e.g., 'USD'
    revenue_value = [NEW_REVENUE_VALUE_NUMERIC],
    revenue_currency = '[NEW_REVENUE_CURRENCY_TEXT]',
    ebitda = [NEW_EBITDA_VALUE_NUMERIC],
    net_income_value = [NEW_NET_INCOME_VALUE_NUMERIC],
    net_income_currency = '[NEW_NET_INCOME_CURRENCY_TEXT]',
    cost_of_revenue = [NEW_COST_OF_REVENUE_NUMERIC_OR_NULL],
    gross_profit = [NEW_GROSS_PROFIT_NUMERIC_OR_NULL],
    operating_expense = [NEW_OPERATING_EXPENSE_NUMERIC_OR_NULL],
    operating_income = [NEW_OPERATING_INCOME_NUMERIC_OR_NULL],
    free_cash_flow = [NEW_FCF_VALUE_NUMERIC_OR_NULL],
    liabilities = [NEW_LIABILITIES_VALUE_NUMERIC_OR_NULL],
    liabilities_currency = '[NEW_LIABILITIES_CURRENCY_TEXT_OR_NULL]',
    trailing_pe = [NEW_TRAILING_PE_NUMERIC_OR_NULL],
    forward_pe = [NEW_FORWARD_PE_NUMERIC_OR_NULL],
    peg_ratio = [NEW_PEG_RATIO_NUMERIC_OR_NULL],
    price_to_book = [NEW_PRICE_TO_BOOK_NUMERIC_OR_NULL],
    price_to_sales = CASE WHEN COALESCE([NEW_REVENUE_VALUE_NUMERIC_IN_MCAP_CURRENCY_OR_CONVERTED], 0) = 0 THEN NULL ELSE ROUND((market_cap_value / [NEW_REVENUE_VALUE_NUMERIC_IN_MCAP_CURRENCY_OR_CONVERTED])::numeric, 2) END,
    enterprise_to_revenue = CASE WHEN COALESCE([NEW_REVENUE_VALUE_NUMERIC_IN_EV_CURRENCY], 0) = 0 THEN NULL ELSE ROUND((enterprise_value_value / [NEW_REVENUE_VALUE_NUMERIC_IN_EV_CURRENCY])::numeric, 2) END,
    enterprise_to_ebitda = CASE WHEN COALESCE([NEW_EBITDA_VALUE_NUMERIC_IN_EV_CURRENCY], 0) = 0 THEN NULL ELSE ROUND((enterprise_value_value / [NEW_EBITDA_VALUE_NUMERIC_IN_EV_CURRENCY])::numeric, 2) END,
    investments_json = COALESCE(investments_json::jsonb, '{}'::jsonb) || jsonb_build_object(
        'UpdateSource', '[SOURCE_OF_THIS_UPDATE_TEXT]',
        'UpdateDetails', '[KEY_CHANGES_OR_NOTES_TEXT]',
        'ReportDate', '[FINANCIAL_REPORT_DATE_YYYY-MM-DD]'
    ),
    data_source = COALESCE(data_source || '; ', '') || '[NEW_DATA_SOURCE_TEXT]',
    last_updated = NOW()
WHERE company_id = (SELECT id FROM company_vars);

-- Log post-update
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
VALUES ((SELECT id FROM company_vars), 'financials', NOW(), 'Updated financial figures and ratios.');

--------------------------------------------------------------------------
-- Update public.capital_structure
--------------------------------------------------------------------------
-- Log pre-update state
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
SELECT (SELECT id FROM company_vars), 'capital_structure', NOW(), 'Pre-update state: existing_shares=' || COALESCE(cs.existing_shares::TEXT,'NULL') || ', fully_diluted_shares=' || COALESCE(cs.fully_diluted_shares::TEXT,'NULL') FROM public.capital_structure cs WHERE cs.company_id = (SELECT id FROM company_vars);

UPDATE public.capital_structure
SET
    existing_shares = [NEW_SHARES_OUTSTANDING_NUMERIC],
    fully_diluted_shares = [NEW_FULLY_DILUTED_SHARES_NUMERIC_OR_NULL],
    in_the_money_options = GREATEST(0, COALESCE([NEW_FULLY_DILUTED_SHARES_NUMERIC_OR_NULL],0) - COALESCE([NEW_SHARES_OUTSTANDING_NUMERIC],0) ),
    last_updated = NOW()
WHERE company_id = (SELECT id FROM company_vars);

-- Log post-update
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
VALUES ((SELECT id FROM company_vars), 'capital_structure', NOW(), 'Updated share structure information.');

--------------------------------------------------------------------------
-- UPSERT public.mineral_estimates
--------------------------------------------------------------------------
-- Log pre-UPSERT state
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
SELECT (SELECT id FROM company_vars), 'mineral_estimates', NOW(), 'Pre-UPSERT state: reserves_total=' || COALESCE(me.reserves_total_aueq_moz::TEXT,'NULL') || ', resources_total=' || COALESCE(me.resources_total_aueq_moz::TEXT,'NULL') FROM public.mineral_estimates me WHERE me.company_id = (SELECT id FROM company_vars);

INSERT INTO public.mineral_estimates (
    company_id, reserves_total_aueq_moz, measured_indicated_total_aueq_moz, resources_total_aueq_moz, potential_total_aueq_moz,
    reserves_precious_aueq_moz, measured_indicated_precious_aueq_moz, resources_precious_aueq_moz, potential_precious_aueq_moz,
    reserves_non_precious_aueq_moz, measured_indicated_non_precious_aueq_moz, resources_non_precious_aueq_moz, potential_non_precious_aueq_moz,
    mineable_total_aueq_moz, last_updated
) VALUES (
    (SELECT id FROM company_vars),
    [RESERVES_TOTAL_AUEQ_MOZ_NUMERIC_OR_NULL], [MI_TOTAL_AUEQ_MOZ_NUMERIC_OR_NULL], [RESOURCES_TOTAL_AUEQ_MOZ_NUMERIC_OR_NULL], [INFERRED_TOTAL_AUEQ_MOZ_NUMERIC_OR_NULL],
    [RESERVES_PRECIOUS_AUEQ_MOZ_NUMERIC_OR_NULL], [MI_PRECIOUS_AUEQ_MOZ_NUMERIC_OR_NULL], [RESOURCES_PRECIOUS_AUEQ_MOZ_NUMERIC_OR_NULL], [INFERRED_PRECIOUS_AUEQ_MOZ_NUMERIC_OR_NULL],
    [RESERVES_NONPRECIOUS_AUEQ_MOZ_NUMERIC_OR_NULL], [MI_NONPRECIOUS_AUEQ_MOZ_NUMERIC_OR_NULL], [RESOURCES_NONPRECIOUS_AUEQ_MOZ_NUMERIC_OR_NULL], [INFERRED_NONPRECIOUS_AUEQ_MOZ_NUMERIC_OR_NULL],
    [MINEABLE_TOTAL_AUEQ_MOZ_NUMERIC_OR_NULL], NOW()
)
ON CONFLICT (company_id) DO UPDATE SET
    reserves_total_aueq_moz = EXCLUDED.reserves_total_aueq_moz, measured_indicated_total_aueq_moz = EXCLUDED.measured_indicated_total_aueq_moz,
    resources_total_aueq_moz = EXCLUDED.resources_total_aueq_moz, potential_total_aueq_moz = EXCLUDED.potential_total_aueq_moz,
    reserves_precious_aueq_moz = EXCLUDED.reserves_precious_aueq_moz, measured_indicated_precious_aueq_moz = EXCLUDED.measured_indicated_precious_aueq_moz,
    resources_precious_aueq_moz = EXCLUDED.resources_precious_aueq_moz, potential_precious_aueq_moz = EXCLUDED.potential_precious_aueq_moz,
    reserves_non_precious_aueq_moz = EXCLUDED.reserves_non_precious_aueq_moz, measured_indicated_non_precious_aueq_moz = EXCLUDED.measured_indicated_non_precious_aueq_moz,
    resources_non_precious_aueq_moz = EXCLUDED.resources_non_precious_aueq_moz, potential_non_precious_aueq_moz = EXCLUDED.potential_non_precious_aueq_moz,
    mineable_total_aueq_moz = EXCLUDED.mineable_total_aueq_moz, last_updated = EXCLUDED.last_updated;
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
VALUES ((SELECT id FROM company_vars), 'mineral_estimates', NOW(), 'UPSERTED mineral estimates.');

--------------------------------------------------------------------------
-- UPSERT public.production
--------------------------------------------------------------------------
-- Log pre-UPSERT state
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
SELECT (SELECT id FROM company_vars), 'production', NOW(), 'Pre-UPSERT state: current_prod_total=' || COALESCE(p.current_production_total_aueq_koz::TEXT,'NULL') FROM public.production p WHERE p.company_id = (SELECT id FROM company_vars);

INSERT INTO public.production (
    company_id, current_production_total_aueq_koz, current_production_precious_aueq_koz, current_production_non_precious_aueq_koz,
    future_production_total_aueq_koz, reserve_life_years, protected, last_updated
) VALUES (
    (SELECT id FROM company_vars),
    [CURRENT_PROD_TOTAL_AUEQ_KOZ_NUMERIC_OR_0], [CURRENT_PROD_PRECIOUS_AUEQ_KOZ_NUMERIC_OR_0], [CURRENT_PROD_NONPRECIOUS_AUEQ_KOZ_NUMERIC_OR_0],
    [FUTURE_PROD_TOTAL_AUEQ_KOZ_NUMERIC_OR_NULL],
    CASE
        WHEN COALESCE([CURRENT_PROD_TOTAL_AUEQ_KOZ_NUMERIC_OR_0], 0) = 0 OR COALESCE([RESERVES_TOTAL_AUEQ_MOZ_NUMERIC_OR_NULL], 0) = 0 THEN NULL
        ELSE ROUND((([RESERVES_TOTAL_AUEQ_MOZ_NUMERIC_OR_NULL] * 1000.0) / [CURRENT_PROD_TOTAL_AUEQ_KOZ_NUMERIC_OR_0])::numeric, 1)
    END,
    FALSE, NOW()
)
ON CONFLICT (company_id) DO UPDATE SET
    current_production_total_aueq_koz = EXCLUDED.current_production_total_aueq_koz, current_production_precious_aueq_koz = EXCLUDED.current_production_precious_aueq_koz,
    current_production_non_precious_aueq_koz = EXCLUDED.current_production_non_precious_aueq_koz,
    future_production_total_aueq_koz = COALESCE(public.production.future_production_total_aueq_koz, EXCLUDED.future_production_total_aueq_koz),
    reserve_life_years = EXCLUDED.reserve_life_years, protected = EXCLUDED.protected, last_updated = EXCLUDED.last_updated;
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
VALUES ((SELECT id FROM company_vars), 'production', NOW(), 'UPSERTED production data.');

--------------------------------------------------------------------------
-- UPSERT public.costs
--------------------------------------------------------------------------
-- Log pre-UPSERT state
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
SELECT (SELECT id FROM company_vars), 'costs', NOW(), 'Pre-UPSERT state: aisc_last_year=' || COALESCE(c.aisc_last_year::TEXT,'NULL') || ', construction_costs=' || COALESCE(c.construction_costs::TEXT,'NULL') FROM public.costs c WHERE c.company_id = (SELECT id FROM company_vars);

INSERT INTO public.costs (
    company_id, tco_current, tco_current_currency, aisc_last_year, aisc_last_year_currency,
    aisc_last_quarter, aisc_last_quarter_currency,
    tco_future, tco_future_currency, aisc_future, aisc_future_currency,
    construction_costs, construction_costs_currency, last_updated
) VALUES (
    (SELECT id FROM company_vars),
    [TCO_CURRENT_USD_NUMERIC_OR_NULL], 'USD', [AISC_LAST_YEAR_USD_NUMERIC_OR_NULL], 'USD',
    [AISC_LAST_QUARTER_USD_NUMERIC_OR_NULL], 'USD',
    [TCO_FUTURE_USD_NUMERIC_OR_NULL], 'USD', [AISC_FUTURE_USD_NUMERIC_OR_NULL], 'USD',
    [CONSTRUCTION_COSTS_USD_NUMERIC_OR_NULL], 'USD', NOW()
)
ON CONFLICT (company_id) DO UPDATE SET
    tco_current = COALESCE(public.costs.tco_current, EXCLUDED.tco_current), tco_current_currency = COALESCE(public.costs.tco_current_currency, EXCLUDED.tco_current_currency),
    aisc_last_year = COALESCE(public.costs.aisc_last_year, EXCLUDED.aisc_last_year), aisc_last_year_currency = COALESCE(public.costs.aisc_last_year_currency, EXCLUDED.aisc_last_year_currency),
    aisc_last_quarter = COALESCE(public.costs.aisc_last_quarter, EXCLUDED.aisc_last_quarter), aisc_last_quarter_currency = COALESCE(public.costs.aisc_last_quarter_currency, EXCLUDED.aisc_last_quarter_currency),
    tco_future = COALESCE(public.costs.tco_future, EXCLUDED.tco_future), tco_future_currency = COALESCE(public.costs.tco_future_currency, EXCLUDED.tco_future_currency),
    aisc_future = COALESCE(public.costs.aisc_future, EXCLUDED.aisc_future), aisc_future_currency = COALESCE(public.costs.aisc_future_currency, EXCLUDED.aisc_future_currency),
    construction_costs = COALESCE(public.costs.construction_costs, EXCLUDED.construction_costs), construction_costs_currency = COALESCE(public.costs.construction_costs_currency, EXCLUDED.construction_costs_currency),
    last_updated = EXCLUDED.last_updated;
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
VALUES ((SELECT id FROM company_vars), 'costs', NOW(), 'UPSERTED cost data.');

--------------------------------------------------------------------------
-- UPSERT public.company_urls
--------------------------------------------------------------------------
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
VALUES ((SELECT id FROM company_vars), 'company_urls', NOW(), 'Attempting to UPSERT company website URL.');

INSERT INTO public.company_urls (company_id, url_type, url, last_validated)
VALUES ((SELECT id FROM company_vars), 'company_website', '[NEW_COMPANY_WEBSITE_URL_TEXT]', NOW())
ON CONFLICT (company_id, url_type) DO UPDATE SET
    url = EXCLUDED.url,
    last_validated = EXCLUDED.last_validated;
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
VALUES ((SELECT id FROM company_vars), 'company_urls', NOW(), 'UPSERTED company website URL.');

--------------------------------------------------------------------------
-- UPSERT public.valuation_metrics
--------------------------------------------------------------------------
-- Log pre-UPSERT state
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
SELECT (SELECT id FROM company_vars), 'valuation_metrics', NOW(), 'Pre-UPSERT state for company' FROM public.valuation_metrics vm WHERE vm.company_id = (SELECT id FROM company_vars);

WITH current_data AS (
    SELECT
        (SELECT id FROM company_vars) AS company_id,
        COALESCE(f.market_cap_value / NULLIF([FX_RATE_CAD_PER_USD_NUMERIC_FOR_MCAP_IF_NEEDED], 1.0), NULL) AS mcap_usd,
        COALESCE(f.enterprise_value_value, NULL) AS ev_usd, -- Assuming EV in financials is already target currency (e.g. USD)
        p.current_production_total_aueq_koz AS prod_koz,
        me.reserves_total_aueq_moz AS res_moz,
        me.measured_indicated_total_aueq_moz AS mi_moz,
        me.resources_total_aueq_moz AS total_res_moz
    FROM public.financials f
    LEFT JOIN public.production p ON f.company_id = p.company_id
    LEFT JOIN public.mineral_estimates me ON f.company_id = me.company_id
    WHERE f.company_id = (SELECT id FROM company_vars)
)
INSERT INTO public.valuation_metrics (
    company_id, ev_per_production_oz, mkt_cap_per_production_oz,
    ev_per_reserve_oz_all, mkt_cap_per_reserve_oz_all,
    ev_per_mi_oz_all, mkt_cap_per_mi_oz_all,
    ev_per_resource_oz_all, mkt_cap_per_resource_oz_all,
    last_updated
)
SELECT
    company_id,
    CASE WHEN COALESCE(prod_koz, 0) = 0 THEN NULL ELSE ROUND((ev_usd / (prod_koz * 1000.0))::numeric, 2) END,
    CASE WHEN COALESCE(prod_koz, 0) = 0 THEN NULL ELSE ROUND((mcap_usd / (prod_koz * 1000.0))::numeric, 2) END,
    CASE WHEN COALESCE(res_moz, 0) = 0 THEN NULL ELSE ROUND((ev_usd / (res_moz * 1000000.0))::numeric, 2) END,
    CASE WHEN COALESCE(res_moz, 0) = 0 THEN NULL ELSE ROUND((mcap_usd / (res_moz * 1000000.0))::numeric, 2) END,
    CASE WHEN COALESCE(mi_moz, 0) = 0 THEN NULL ELSE ROUND((ev_usd / (mi_moz * 1000000.0))::numeric, 2) END,
    CASE WHEN COALESCE(mi_moz, 0) = 0 THEN NULL ELSE ROUND((mcap_usd / (mi_moz * 1000000.0))::numeric, 2) END,
    CASE WHEN COALESCE(total_res_moz, 0) = 0 THEN NULL ELSE ROUND((ev_usd / (total_res_moz * 1000000.0))::numeric, 2) END,
    CASE WHEN COALESCE(total_res_moz, 0) = 0 THEN NULL ELSE ROUND((mcap_usd / (total_res_moz * 1000000.0))::numeric, 2) END,
    NOW()
FROM current_data
ON CONFLICT (company_id) DO UPDATE SET
    ev_per_production_oz = EXCLUDED.ev_per_production_oz, mkt_cap_per_production_oz = EXCLUDED.mkt_cap_per_production_oz,
    ev_per_reserve_oz_all = EXCLUDED.ev_per_reserve_oz_all, mkt_cap_per_reserve_oz_all = EXCLUDED.mkt_cap_per_reserve_oz_all,
    ev_per_mi_oz_all = EXCLUDED.ev_per_mi_oz_all, mkt_cap_per_mi_oz_all = EXCLUDED.mkt_cap_per_mi_oz_all,
    ev_per_resource_oz_all = EXCLUDED.ev_per_resource_oz_all, mkt_cap_per_resource_oz_all = EXCLUDED.mkt_cap_per_resource_oz_all,
    last_updated = EXCLUDED.last_updated;

-- Log post-update
INSERT INTO public.update_log (company_id, table_name, update_time, update_description)
VALUES ((SELECT id FROM company_vars), 'valuation_metrics', NOW(), 'UPSERTED and recalculated all valuation metrics.');

--------------------------------------------------------------------------
-- Final Verification Query (Example)
--------------------------------------------------------------------------
SELECT
    c.company_id, c.tsx_code, c.company_name, c.status,
    f.market_cap_value AS f_mcap, f.market_cap_currency AS f_mcap_curr,
    f.enterprise_value_value AS f_ev, f.enterprise_value_currency AS f_ev_curr,
    f.revenue_value AS f_rev, f.ebitda AS f_ebitda, f.net_income_value AS f_ni,
    f.shares_outstanding AS f_shares, cs.fully_diluted_shares AS cs_fd_shares,
    me.reserves_total_aueq_moz AS res_moz, me.measured_indicated_total_aueq_moz AS mi_moz, me.resources_total_aueq_moz AS total_res_moz,
    p.current_production_total_aueq_koz AS prod_koz, p.reserve_life_years,
    k.aisc_last_year, k.aisc_last_year_currency, k.aisc_future, k.aisc_future_currency, k.construction_costs,
    (SELECT url FROM public.company_urls cu WHERE cu.company_id = c.company_id AND cu.url_type = 'company_website' LIMIT 1) AS website,
    vm.ev_per_production_oz, vm.mkt_cap_per_reserve_oz_all
FROM public.companies c
LEFT JOIN public.financials f ON c.company_id = c.company_id
LEFT JOIN public.capital_structure cs ON c.company_id = cs.company_id
LEFT JOIN public.mineral_estimates me ON c.company_id = me.company_id
LEFT JOIN public.production p ON c.company_id = p.company_id
LEFT JOIN public.costs k ON c.company_id = k.company_id
LEFT JOIN public.valuation_metrics vm ON c.company_id = vm.company_id
WHERE c.company_id = (SELECT id FROM company_vars);

COMMIT;
----




Data Source Handling:
Yahoo Finance: Provides reliable market cap, share counts, financials (revenue, EBITDA, etc.), and valuation ratios. Data is in CAD for market cap/EV and USD for income statements.

GoldStockData: Offers detailed resource estimates (gold/silver in Moz), production data, and costs. Often uses USD and provides “guess” values that need validation.

Challenges: Name mismatches, differing share counts, and incomplete data require reconciliation. GoldStockData’s “guess” production estimates need cross-checking with Yahoo or company reports.

Update Challenges:
Data Persistence: Updates to production and valuation_metrics sometimes fail to save, possibly due to transaction issues or constraints.

Error Detection: Extreme valuation ratios (e.g., >$100,000/oz) indicate errors or transitional companies (e.g., i-80 Gold).

Manual Verification: Critical for explorers/developers with no production or for companies with large capex plans.

Rules for Robust Updates
Data Validation:
Always cross-check share counts between financials.shares_outstanding and capital_structure.existing_shares. Flag differences >10%.

Validate enterprise_value_value using the formula: market_cap_value + debt_value - cash_value. Flag deviations >10%.

For producers, ensure current_production_total_aueq_koz is non-zero. For developers/explorers, allow zero production but require reserves/resources.

Convert silver to gold equivalent using a 80:1 ratio for mineral_estimates (e.g., 80Moz silver = 1Moz AuEq).

Use a consistent CAD/USD exchange rate (e.g., 1.36) for conversions.

Data Source Prioritization:
Use Yahoo Finance for market cap, enterprise value, share counts, and financials (revenue, EBITDA, etc.) due to its recency and reliability.

Use GoldStockData for resource estimates, production, and cost data, but verify “guess” values against company reports or Yahoo.

If data sources conflict (e.g., share counts), prefer Yahoo for financials and GoldStockData for resources, and add a note in investments_json.

Handling Special Cases:
Royalty Companies: Set status = 'royalty', ensure no reserves in mineral_estimates, and append a description note without overwriting.

Transitional Companies (e.g., i-80 Gold): Flag high EV/production ratios (>20,000/oz) with a note in investments_json explaining the transitional nature.

Missing Data: For NULL fields in non-critical metrics (e.g., peg_ratio), set to NULL rather than zero to distinguish valid absences.

Update Safety:
Use ON CONFLICT clauses for stock_prices to avoid duplicate entries.

Always update last_updated to NOW() for traceability.

Include data_source in updates to track origin (e.g., 'Yahoo Finance + GoldStockData').

Run updates in a transaction to ensure consistency across tables.

Log data quality issues in investments_json for manual review.

Error Prevention:
Check for extreme valuation metrics (>100,000/oz for production, >5,000/oz for reserves).

Ensure production data for producers is non-zero; flag as critical if missing.

Verify share counts align with market cap (e.g., market_cap_value / shares_outstanding should approximate stock price).

SQL Update Template
Below is a generalized SQL update template for updating a company based on data dumps from Yahoo Finance and GoldStockData. It incorporates the learnings and rules above, ensuring robust updates.


BEGIN;

-- Update company information
UPDATE public.companies
SET
    company_name = '[COMPANY_NAME]',
    tsx_code = '[TSX_CODE]',
    status = '[producer|developer|explorer|royalty]',
    headquarters = '[HEADQUARTERS]',
    description = CASE 
        WHEN description NOT LIKE '%[Data Source:%' THEN 
            CONCAT(description, ' [Data Source: Yahoo Finance + GoldStockData, Updated: ', CURRENT_DATE::text, ']')
        ELSE 
            description
    END,
    minerals_of_interest = '[gold|silver|gold,silver]',
    percent_gold = [PERCENT_GOLD],
    percent_silver = [PERCENT_SILVER],
    last_updated = NOW()
WHERE company_id = [COMPANY_ID];

-- Update financial data
UPDATE public.financials
SET
    cash_value = [CASH_VALUE],  -- From Yahoo or GoldStockData, in USD or CAD
    cash_currency = '[USD|CAD]',
    cash_date = '[CASH_DATE]',
    debt_value = [DEBT_VALUE],
    debt_currency = '[USD|CAD]',
    market_cap_value = [MARKET_CAP_VALUE],  -- From Yahoo, in CAD
    market_cap_currency = 'CAD',
    enterprise_value_value = [ENTERPRISE_VALUE_VALUE],  -- From Yahoo, in CAD
    enterprise_value_currency = 'CAD',
    revenue_value = [REVENUE_VALUE],  -- From Yahoo income statement
    revenue_currency = 'USD',
    cost_of_revenue = [COST_OF_REVENUE],
    gross_profit = [GROSS_PROFIT],
    operating_expense = [OPERATING_EXPENSE],
    operating_income = [OPERATING_INCOME],
    net_income_value = [NET_INCOME_VALUE],
    net_income_currency = 'USD',
    ebitda = [EBITDA],
    free_cash_flow = [FREE_CASH_FLOW],
    liabilities = [LIABILITIES],
    liabilities_currency = '[USD|CAD]',
    net_financial_assets = [CASH_VALUE - DEBT_VALUE],
    net_financial_assets_currency = '[USD|CAD]',
    shares_outstanding = [SHARES_OUTSTANDING],  -- Prefer Yahoo
    trailing_pe = [TRAILING_PE],
    forward_pe = [FORWARD_PE],
    peg_ratio = [PEG_RATIO],
    price_to_sales = [PRICE_TO_SALES],
    price_to_book = [PRICE_TO_BOOK],
    enterprise_to_revenue = [ENTERPRISE_TO_REVENUE],
    enterprise_to_ebitda = [ENTERPRISE_TO_EBITDA],
    investments_json = jsonb_build_object(
        'note', '[DATA_QUALITY_NOTES]',
        'data_source', 'Yahoo Finance + GoldStockData',
        'share_count_source', '[Yahoo|GoldStockData]',
        'last_reviewed', CURRENT_DATE::text
    )::text,
    data_source = 'Yahoo Finance + GoldStockData',
    last_updated = NOW()
WHERE company_id = [COMPANY_ID];

-- Update capital structure
UPDATE public.capital_structure
SET
    existing_shares = [EXISTING_SHARES],  -- Prefer Yahoo
    fully_diluted_shares = [FULLY_DILUTED_SHARES],  -- From GoldStockData if available
    in_the_money_options = [FULLY_DILUTED_SHARES - EXISTING_SHARES],
    last_updated = NOW()
WHERE company_id = [COMPANY_ID];

-- Update mineral estimates
UPDATE public.mineral_estimates
SET
    reserves_precious_aueq_moz = [GOLD_RESERVES_P&P],
    measured_indicated_precious_aueq_moz = [GOLD_M&I],
    resources_precious_aueq_moz = [GOLD_TOTAL_RESOURCES],
    potential_precious_aueq_moz = [GOLD_INFERRED],
    mineable_precious_aueq_moz = [GOLD_PLAUSIBLE],
    
    reserves_non_precious_aueq_moz = [SILVER_RESERVES_P&P / 80],
    measured_indicated_non_precious_aueq_moz = [SILVER_M&I / 80],
    resources_non_precious_aueq_moz = [SILVER_TOTAL_RESOURCES / 80],
    potential_non_precious_aueq_moz = [SILVER_INFERRED / 80],
    mineable_non_precious_aueq_moz = [SILVER_PLAUSIBLE / 80],
    
    reserves_total_aueq_moz = [GOLD_RESERVES_P&P + SILVER_RESERVES_P&P / 80],
    measured_indicated_total_aueq_moz = [GOLD_M&I + SILVER_M&I / 80],
    resources_total_aueq_moz = [GOLD_TOTAL_RESOURCES + SILVER_TOTAL_RESOURCES / 80],
    potential_total_aueq_moz = [GOLD_INFERRED + SILVER_INFERRED / 80],
    mineable_total_aueq_moz = [GOLD_PLAUSIBLE + SILVER_PLAUSIBLE / 80],
    
    last_updated = NOW()
WHERE company_id = [COMPANY_ID];

-- Update production data
UPDATE public.production
SET
    current_production_precious_aueq_koz = [GOLD_PRODUCTION_CURRENT],
    current_production_non_precious_aueq_koz = [SILVER_PRODUCTION_CURRENT / 80],
    current_production_total_aueq_koz = [GOLD_PRODUCTION_CURRENT + SILVER_PRODUCTION_CURRENT / 80],
    future_production_total_aueq_koz = [GOLD_FUTURE_PRODUCTION + SILVER_FUTURE_PRODUCTION / 80],
    reserve_life_years = CASE 
        WHEN [GOLD_RESERVES_P&P + SILVER_RESERVES_P&P / 80] > 0 
        THEN ROUND(([GOLD_RESERVES_P&P + SILVER_RESERVES_P&P / 80] * 1000) / NULLIF([GOLD_PRODUCTION_CURRENT + SILVER_PRODUCTION_CURRENT / 80], 0), 1)
        ELSE NULL 
    END,
    last_updated = NOW()
WHERE company_id = [COMPANY_ID];

-- Update costs
UPDATE public.costs
SET
    aisc_last_year = [AISC_CURRENT],
    aisc_last_year_currency = 'USD',
    aisc_future = [AISC_FUTURE],
    aisc_future_currency = 'USD',
    construction_costs = [CONSTRUCTION_COSTS],
    construction_costs_currency = '[USD|CAD]',
    tco_current = [CASH_COST_CURRENT],
    tco_current_currency = 'USD',
    tco_future = [CASH_COST_FUTURE],
    tco_future_currency = 'USD',
    last_updated = NOW()
WHERE company_id = [COMPANY_ID];

-- Update stock price
INSERT INTO public.stock_prices (company_id, price_value, price_currency, price_date, data_source)
VALUES ([COMPANY_ID], [PRICE_VALUE], 'CAD', CURRENT_DATE, 'Yahoo Finance')
ON CONFLICT (company_id, price_date, data_source) 
DO UPDATE SET
    price_value = EXCLUDED.price_value,
    price_currency = EXCLUDED.price_currency;

-- Recalculate valuation metrics
UPDATE public.valuation_metrics
SET
    mkt_cap_per_reserve_oz_all = ROUND([MARKET_CAP_VALUE]::numeric / NULLIF([TOTAL_RESERVES_AUEQ * 1000000], 0), 2),
    mkt_cap_per_mi_oz_all = ROUND([MARKET_CAP_VALUE]::numeric / NULLIF([TOTAL_M&I_AUEQ * 1000000], 0), 2),
    mkt_cap_per_resource_oz_all = ROUND([MARKET_CAP_VALUE]::numeric / NULLIF([TOTAL_RESOURCES_AUEQ * 1000000], 0), 2),
    mkt_cap_per_mineable_oz_all = ROUND([MARKET_CAP_VALUE]::numeric / NULLIF([MINEABLE_AUEQ * 1000000], 0), 2),
    ev_per_reserve_oz_all = ROUND([ENTERPRISE_VALUE_VALUE]::numeric / NULLIF([TOTAL_RESERVES_AUEQ * 1000000], 0), 2),
    ev_per_mi_oz_all = ROUND([ENTERPRISE_VALUE_VALUE]::numeric / NULLIF([TOTAL_M&I_AUEQ * 1000000], 0), 2),
    ev_per_resource_oz_all = ROUND([ENTERPRISE_VALUE_VALUE]::numeric / NULLIF([TOTAL_RESOURCES_AUEQ * 1000000], 0), 2),
    ev_per_mineable_oz_all = ROUND([ENTERPRISE_VALUE_VALUE]::numeric / NULLIF([MINEABLE_AUEQ * 1000000], 0), 2),
    mkt_cap_per_production_oz = ROUND([MARKET_CAP_VALUE]::numeric / NULLIF([CURRENT_PRODUCTION_AUEQ * 1000], 0), 2),
    ev_per_production_oz = ROUND([ENTERPRISE_VALUE_VALUE]::numeric / NULLIF([CURRENT_PRODUCTION_AUEQ * 1000], 0), 2),
    last_updated = NOW()
WHERE company_id = [COMPANY_ID];

-- Verify enterprise value
UPDATE public.financials
SET
    enterprise_value_value = [MARKET_CAP_VALUE + DEBT_VALUE - CASH_VALUE],
    enterprise_value_currency = '[CAD|USD]',
    last_updated = NOW()
WHERE company_id = [COMPANY_ID]
  AND ABS(enterprise_value_value - ([MARKET_CAP_VALUE + DEBT_VALUE - CASH_VALUE])) > [MARKET_CAP_VALUE] * 0.1;

COMMIT;


How to Use the Template:
Replace placeholders (e.g., [COMPANY_NAME], [MARKET_CAP_VALUE]) with data from Yahoo Finance or GoldStockData.

For currency conversions, apply a 1.36 CAD/USD rate when needed (e.g., convert Yahoo’s CAD market cap to USD for valuation metrics).

Add data quality notes in investments_json if there are discrepancies or “guess” values.

Run within a BEGIN/COMMIT transaction to ensure atomic updates.

Validate inputs against expected ranges (e.g., ev_per_production_oz < 100,000, market_cap_value / shares_outstanding ≈ stock price).


